<!DOCTYPE html>
<html lang="ja">
<head>
  <title>Babylon.js + MapLibre 複数モデル表示</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  https://unpkg.com/maplibre-gl@5.6.2/dist/maplibre-gl.css
  https://unpkg.com/maplibre-gl@5.6.2/dist/maplibre-gl.js
  https://unpkg.com/babylonjs@5.42.2/babylon.js
  https://unpkg.com/babylonjs-loaders@5.42.2/babylonjs.loaders.min.js
  <style>
    body { margin: 0; padding: 0; }
    html, body, #map { height: 100%; }
  </style>
</head>
<body>
<div id="map"></div>
<script>
  const params = new URLSearchParams(window.location.search);
  const models = JSON.parse(params.get('models') || '[]');

  const BABYLON = window.BABYLON;

  const map = new maplibregl.Map({
    container: 'map',
    style: 'https://api.maptiler.com/maps/basic/style.json?key=rtAeicf6fB2vbuvHChpL',
    zoom: 18,
    center: [models[0]?.lon || 140.3032, models[0]?.lat || 35.3537],
    pitch: 60,
    canvasContextAttributes: { antialias: true }
  });

  const customLayer = {
    id: '3d-models',
    type: 'custom',
    renderingMode: '3d',
    onAdd(map, gl) {
      this.engine = new BABYLON.Engine(gl, true, { useHighPrecisionMatrix: true }, true);
      this.scene = new BABYLON.Scene(this.engine);
      this.scene.autoClear = false;
      this.scene.detachControl();

      this.camera = new BABYLON.Camera('Camera', new BABYLON.Vector3(0, 0, 0), this.scene);
      new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 0, 100), this.scene).intensity = 0.7;

      // モデルファイル名（全モデル共通）
      const modelUrl = models[0]?.modelUrl || 'AirconModel.glb';

      // モデルを1回だけ読み込み
      BABYLON.SceneLoader.ImportMeshAsync(null,
        'https://pckk-device.s3.ap-southeast-2.amazonaws.com/',
        modelUrl,
        this.scene
      ).then(result => {
        const originalMesh = result.meshes[0];
        originalMesh.setEnabled(false); // テンプレートとして非表示

        models.forEach((model, index) => {
          const {
            lon, lat, scale = 1,
            rx = Math.PI / 2, ry = 0, rz = 0
          } = model;

          const mercator = maplibregl.MercatorCoordinate.fromLngLat([lon, lat], 0);
          const position = new BABYLON.Vector3(mercator.x, mercator.y, mercator.z);
          const quaternion = BABYLON.Quaternion.FromEulerAngles(rx, ry, rz);
          const scaling = new BABYLON.Vector3(scale, scale, scale);

          const clonedMesh = originalMesh.clone(`clone-${index}`);
          clonedMesh.setEnabled(true);
          clonedMesh.scaling = scaling;
          clonedMesh.rotationQuaternion = quaternion;
          clonedMesh.position = position;
        });
      });

      this.map = map;
    },
    render(gl, args) {
      const cameraMatrix = BABYLON.Matrix.FromArray(args.defaultProjectionData.mainMatrix);
      this.camera.freezeProjectionMatrix(cameraMatrix);
      this.scene.render(false);
      this.map.triggerRepaint();
    }
  };

  map.on('style.load', () => {
    map.addLayer(customLayer);
  });
</script>
</body>
</html>

